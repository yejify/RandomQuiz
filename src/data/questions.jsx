const questionsData = [
  {
    question: 'CSS에서 display 속성과 각 요소들에 대해서 설명해 주세요.',
    answer:
      'display 속성에는 차지하는 공간이 없는 none, 한 줄 전체를 차지하는 block, 요소의 크만큼만 자리를 차지하는 inline, inline과 block 속성을 합친 것으로 요소의 크기만큼만 자리를 차지하면서 width와 height 값을 수정할 수 있는 inline-block, 레이아웃을 위한 flex, grid, 그리고 요소를 table 태그처럼 쓸 수 있는 table 속성 등이 있습니다.',
  },
  {
    question: 'margin collapsing 현상',
    answer:
      '마진 병합 현상이란 인접하는 블록요소의 상하단의 마진이 병합되는 현상입니다. 이때, 마진의 크기는 병합되는 마진 중에서 큰 값을 가진 마진의 값으로 병합됩니다. 부모 자식 요소간에도 마진 병합 현상이 나타나는데요. 이를 해결하기 위해서 자식 요소에 display: inline-block을 적용해줄 수 있습니다. 자식 요소의 마진병합은 일어나지 않게 해주려면 부모요소에 overflow:hidden을 적용해주면됩니다. 또한, 부모요소에 display: flex나 grid를 적용해줄 수 있습니다.',
  },
  {
    question:
      'CSS에서 C는 Cascading을 의미하는데 Cascading에 대한 설명과 cascading system의 장점은?',
    answer:
      'Cascading은 폭포같은, 연속된다는 뜻을 가지고 있습니다. CSS에서 cascading은 스타일 규칙의 적용 우선순위와 상속에 관련된 개념입니다. 스타일 규칙이 계단식으로 적용되어 부모 요소로부터 자식 요소까지 연속적으로 전파됩니다. 이와 같은 상속을 통해 코드 작성량을 줄이고 일관된 디자인을 유지할 수 있습니다. 또한, 선택자에 따른 우선순위를 통해 스타일 규칙을 적용하여 원하는 스타일을 정확하게 구현할 수 있습니다.',
  },
  {
    question:
      'CSS, SCSS, SASS의 차이점과 리액트와 사용할 거면 무엇을 쓸 건지 설명하세요.',
    answer:
      '저는 이 세가지 중에서 SCSS를 주로 사용해왔습니다. 왜냐하면 SCSS는 CSS의 문법을 그대로 사용하기에 호환성이 좋기 때문입니다. CSS에서는 셀렉터를 중복해서 사용하는 경우가 많았습니다. 그렇기 때문에 변수, 함수, 연산자를 만들어서 사용할 수 있는 SCSS와 SASS 중에서 고민하였습니다. SCSS와 SASS의 차이점에는{}(중괄호)와 ;(세미콜론)의 유무라고 말씀드릴 수 있습니다. 이 점에서는 생략되어지는 SASS가 편리할 수 있지만 mixin문법에서는 +와 -로 표시하기 때문에 직관적으로 코드가 보이지 않는 불편함이 있었습니다. 그렇기 때문에 저는 익숙한 CSS 문법을 사용하는 SCSS를 사용할 것입니다.',
  },
  {
    question: 'CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요?',
    answer:
      '절대 길이 단위와 상대 길이 단위로 나누게 됩니다. 절대 길이 단위는 물리적인 측정 거리를 의미합니다. px은 절대길이 단위로, 일반적인 모니터 디스플레이의 1픽셀을 의미합니다. 나머지 단위들은 상대길이 단위입니다. 상대 길이 단위는 다시 글꼴 상대 길이와 뷰포트 백분율 길이로 나뉘게 됩니다. 글꼴 상대 길이는 길이값을 특정 문자나 현재 사용하는 폰트를 기준으로 설정하는 반면에 뷰포트 백분율 길이는 길이 값을 뷰포느 기준으로 설정합니다. em과 rem은 글꼴 상대 길이이며, vh와 vw는 뷰포트 상대 길이 입니다. em은 부모 요소의 폰트 사이즈를 기준으로 하는 반면에 rem은 루트요소 즉, 일반적으로 <html>요소의 폰트 사이즈를 기준으로 합니다. 그리고 vh는 뷰포트의 초기 컨테이너 블록의 높이 1%를 기준으로 하는 반면, vw는 뷰포트의 초기 컨테이너 블록의 너비 1%를 기준으로 합니다.',
  },
  {
    question: 'CSS에서 margin과 padding에 대해서 설명해주세요.',
    answer:
      'margin과 padding은 모두 요소 주위에 공간을 만드는 데 사용되는 CSS 속성입니다. 그러나 그들은 다른 목적을 가지고 있습니다. margin은 요소의 border 외부에 여백을 만드는 데 사용되고, padding은 콘텐츠와 border 사이에 내부 여백을 만드는 데 사용됩니다. 다시 말해, margin은 요소의 위치를 다른 요소에 상대적으로 영향을 주고, padding은 요소 내부의 콘텐츠의 위치 혹은 크기에 영향을 줍니다.',
  },
  {
    question: '클로저에 대해서 설명해주세요.',
    answer:
      '클로저는 사전에서 폐쇄라는 뜻을 가지고 있습니다. 자바스크립트의 클로저도 폐쇄와 유사한 의미를 가지고 있습니다. 클로저란 함수가 선언될 당시에 주변의 환경과 함께 갇히는 것을 말합니다. 이때의 환경은 함수가 속한 렉시컬 스코프를 의미하고 렉시컬 스코프란 함수가 선언되는 위치에따라 상위 스코프가 결정되는 스코프입니다. 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 해주는 기능입니다. 내부함수에서 외부함수의 지역변수에 접근할 수 있다는 의미입니다. 외부함수의 실행이 끝난 후에도 내부함수에서는 해당 변수를 참조하고있기 때문에 접근이 가능하여 클로저는 데이터 보존의 장점이 있습니다.',
  },
  {
    question: 'event loop에 대해서 설명하세요',
    answer:
      '자바스크립트는 단일 스레드 기반의 언어로 한 번에 하나의 작업만 처리할 수 있습니다. 그렇기 때문에 자바스크립트 엔진은 어떤 작업을 하면 중간에 어떤 함수도 실행될 수 없습니다. 하지만 그렇게 작업을 하게 되면 너무 많은 시간을 사용자는 기다려야합니다. 이러한 문제점을 해결하고자 함수 호출을 관리하는 call stack과 비동기 작업 처리를 위해 Web API가 함께 작업을 처리하게 됩니다. Web API는 작업 완료에 시간이 오래 걸리는 작업을 처리하게 되는데 이 결과값을 처리할 수 있는 callback 함수를 task queue에 쌓습니다. 이 때 작업이 다 완료가 되어서 call stack이 비어있게 되면 task queue의 담겨 있는 callback 함수를 다시 call stack으로 담아서 callback을 실행시키게 됩니다. 이 작업이 event loop입니다. JavaScript event loop는 call stack이 비어있는 경우, task queue에서 대기하던 callback을 call stack으로 옮겨서 callback을 실행시켜주는 역할을 합니다.',
  },
  {
    question: '호이스팅에 대해서 설명해주세요.',
    answer:
      '다른 언어와 차별되는 자바스크립트의 특징으로 모든 선언문이 해당 스코프의 선두로 옮겨진 것처럼 동작하는 특성을 말합니다. 이것은 모든 선언문이 선언되기 이전에 참조 가능하다는 것을 의미합니다. 호이스팅이 이루어지는 과정은 변수가 생성되는 3가지 단계에서 자세하게 살펴볼 수 있습니다. 선언단계에서는 변수객체에 변수를 등록합니다. 이때 변수객체는 스코프가 참조하는 대상이 됩니다. 초기화 단계에서는 변수 객체에 등록된 변수를 메모리에 할당합니다. 이때 변수가 undefined로 초기화됩니다. 할당 단계에서는 초기화된 변수에 실제 값을 할당합니다. var로 선언한 변수는 호이스팅에 의해 선언 단계에서 스코프 맨 위로 끌어올려집니다. 이로 인해 변수를 선언하기 전에 사용할 수 있으며, 이는 예상치 못한 동작을 초래할 수 있습니다. var는 같은 변수를 여러 번 선언해도 오류를 발생시키지 않습니다. 이는 변수 값이 예상치 않게 덮어씌워질 수 있어 디버깅을 어렵게 만들 수 있습니다. var로 선언한 변수는 블록 스코프를 무시합니다. 예를 들어, **`if`** 블록 내에서 선언한 변수는 블록을 벗어나도 접근할 수 있습니다. 이러한 문제들이 있어  **`let`**과 **`const`** 라는 선언문을 ES6에 추가하여 블록 스코프를 지키고 TDZ(Temporarily Dead Zone)를 제공하여 변수가 선언되기 전에 접근하려고 하면 오류가 발생하게 만들었습니다.',
  },
  {
    question: 'Blocking과 Non-Blocking의 차이점은 무엇인가요?',
    answer:
      'Blocking은 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고 호출한 함수가 대기하도록 하는 것입니다. 예를 들어 실행하는 데 10초가 걸리는 A라는 함수가 실행되면 B라는 함수가 실행되기까지 10초간 대기해야합니다. 반면에 Non-Blocking은 호출된 함수가 할일을 마치지 않았더라고 제어권을 내주어 호출한 함수가 다른 일을 진행할 수 있는 것입니다. 예를 들어 A함수가 종료되지 않은 상태여도 바로 B함수를 실행할 수 있습니다.',
  },
  {
    question: '마이크로태스크 큐와 태스크 큐에 대해서 말씀해주세요.',
    answer:
      'Microtask queue와 Task queue는 비동기 처리와 관련된 개념으로, 비동기 작업이 처리된 후 콜백 함수는 콜백 큐에 담기게 됩니다. 이때 콜백 큐의 종류에 microtask queue와 task queue가 있습니다. 마이크로태스크 큐는 Promise, MutationObserver 등과 관련된 비동기 함수의 콜백함수를 처리합니다. 해당 큐에 있는 작업들은 다른 이벤트나 타임아웃보다도 우선적으로 처리됩니다. 태스크 큐는 setTimeout(), setInterval, DOM 이벤트 핸들러 등과 같은 비동기 함수의 콜백 함수를 처리합니다. FIFO 방식으로 함수를 처리합니다.',
  },
  {
    question: '이벤트 버블링에 대해서 말씀해주세요.',
    answer:
      '이벤트 버블링은 DOM 요소에서 이벤트가 발생할 때, 어느 요소에서 발생한 이벤트가 부모요소, 상위 요소로 전파되는 현상을 의미합니다. 이러한 전파 과정은 해당 이벤트가 일어난 하위 요소부터 최상위 요소까지 전달됩니다. 반면 최상위 요소에서부터 하위로 전파되는 방법은 캡쳐링이라고 합니다. 자바스크립트`addEventListener()`함수로 요소의 이벤트를 등록하면 기본적으로 버블링 방식으로 이벤트가 전파되어 리스너가 호출됩니다. 만약 캡처링을 구현하려면 `addEventListener()` 함수의 3번째 매개변수로`true`나 `{ capture: true }`를 설정해주면 됩니다. 이벤트 버블링과 캡처링 때문에 의도하지 않은 동작이 발생할 수 있는데, 이를 방지하고자 한다면 이벤트 객체의 `stopPropagation()`메소드를 이용하면 이벤트 버블링과 캡처링을 막을 수 있습니다.',
  },
  {
    question:
      'callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요.',
    answer:
      '일반적으로 다른 함수의 인자로 전달되는 함수를 callback이라고 합니다. 비동기 작업을 해결하기엔 충분했지만 함수에 담아서 사용해야하기 때문에 코드가 직관적이지 않아서 "callback hell"현상이 일어났습니다. 이 문제를 해결하고자 promise가 탄생하게되었습니다. promise는 성공과 실패라는 executor을 전달해주어야합니다. 이때 작업에 성공했을 경우는 resolve, 실패했을 경우는 reject라고 합니다.그래서 성공 시에는 resolve함수에서 전달된 인자가 인스턴스의 결과값으로 나오게 됩니다. 프로미스 인스턴스는 대기상태인 pending, 성공인 fulfilled, 실패한rejected 3가지 중 하나의 상태를 가집니다. promise는 then과 catch메소드로 프로미스를 리턴하기에 promise chaining이 가능합니다. 하지만 연속되는 비동기 작업이 순서대로 작동되어야하는 경우 콜백지옥처럼 프로미스 지옥이 발생하였습니다. 그래서 async/await가 발생하게 되었습니다. async/await는 동기적으로 작동하는 것처럼 Promise를 조금 더 쉽게 다룰 수 있게 만들어진 문법적 설탕이라고 불립니다. async/await 키워드만 적절히 사용하면 기존 함수를 작성하는 문법을 그대로 살릴 수 있습니다. async 함수를 실행하면 함수 내 리턴값 여부에 상관없이 Promise가 리턴되며, 함수 내의 리턴 값은 Promise result 값으로 전달되어집니다. await 키워드는 async 함수 내에서만 사용이 가능하며 응답이 올때까지 코드 읽기를 멈췄다가 요청이 오고나서야 다음코드를 실행하는 문법입니다. 이때 await로 실행된 코드는 Promise가 아닌 Promise의 result 값을 반환합니다.',
  },
  {
    question: '객체 지향 프로그래밍이란 무엇인가요?',
    answer:
      '객체 지향 프로그래밍이란 좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임으로 로직을 상태와 행위로 이루어진 객체로 만드는 것입니다. 객체들을 마치 레고 블록처럼 조립해서 하나의 프로그램으로 만드는 것이 객체지향 프로그래밍이라고 할 수 있습니다. 4가지 특성 : 캡슐화, 추상화, 상속, 다형성    캡슐화는 각각의 객체들이 클래스 안에서 그들의 상태를 프라이빗하게 유지할 때 얻을 수 있습니다. 다른 객체들이 그 상태에 대해 직접 접근이 불가능하고, 대신 메소드라고 불리는 퍼블릭 함수 목록을 호출하여 상태를 관리할 수 있습니다. 추상화란 객체의 공통적인 속성과 기능을 추출하여 정의하는 것입니다. 실제로 존재하는 객체들을 프로그램으로 만들기 위해 공통 특성을 파악해 필요없는 특성을 제거하는 과정을 가리킵니다. 상속이란 기존 상위 클래스의 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클래스에 새로운 기능도 추가할 수 있습니다. 다형성이란 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있습니다.',
  },
  {
    question: '실행 문맥에 대해서 설명해주세요.',
    answer:
      '실행 컨텍스트란 자바스크립트 코드가 실행되는 환경을 나타내는 개념입니다. 코드 실행에 필요한 정보를 포함하고 있으며, 변수, 함수 선언, 스코프 체인 등과 같은 요소들을 관리합니다. 실행 컨텍스트는 1. 맨 처음 코드가 실행되었을 때 (Global Execution Context 전역 컨텍스트) 2. 함수가 호출되었을 때 (Function Execution Context 함수 컨텍스트) 3. eval()이 사용되었을 때 발생합니다. ES6 기준으로 실행 컨텍스트에는 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보가 담긴 Variable Environment와 처음엔 Variable Environment와 같지만 변경 사항이 실시간으로 반영되는 Lexical Environment, this 식별자가 바라봐야 할 대상 객체를 의미하는 ThisBinding으로 구성되어 있습니다.',
  },
  {
    question: 'Prototype Chaining',
    answer:
      'prototype chaining은 기존에 존재하는 객체를 기반으로 새로운 객체를 생성할 때 사용됩니다. 만약 객체의 프로퍼티에 접근하려고 할 때, 프로퍼티가 없다면 _proto__ 접근자 프로퍼티를 따라서 본인의 부모 역할을 하는 객체를 순차적으로 돌아다니며 검색합니다. Prototype Chaning의 최상위 객체는 Object.prototype이며, 해당 객체의 프로퍼티, 메소드는 모든 객체에게 상속됩니다.',
  },
  {
    question: 'IIFE',
    answer:
      'IIFE는 함수 정의와 동시에 즉시 호출되는 즉시 실행함수를 의미합니다. 즉시실행함수는 단 한번만 호출이 되며 다시 사용할 수 없는 특성이 있습니다. 예를 들어 어떠한 버튼을 클릭할 때마다 카운트를 올려주고, 해당 클릭 수를 alert창으로 띄워준다고 가정해보겠습니다. `count`라는 전역변수를 선언한 후 해당 변수를 계속해서 참조할 수도 있겠지만, click하는 event handler 자체에 해당 데이터를 넣는 방법이 더 좋을 것 같습니다. 그렇게 되면 추가적인 변수로 global scope를 더럽히지 않고, IIFE를 적용해 closure를 조정하여 `count`변수를 외부에서 참조하지 못하도록 보호 할 수 있게 됩니다. 이러한 상황에서 IIFE가 사용되어지기에 `count`에 담겨있는 데이터의 부작용을 사전에 방지시킬 수 있습니다.',
  },
  {
    question: '스코프 체인(Scope Chain)',
    answer:
      '스코프 체인(Scope Chain)은 JavaScript에서 변수의 유효 범위를 나타내는 개념입니다. 각 함수가 생성될 때마다 해당 함수의 스코프가 형성되고, 이 스코프들은 중첩된 구조로 연결됩니다. 이 구조가 스코프 체인이라고 불리며, 변수 검색 시 해당 스코프 체인을 따라가며 찾게 됩니다. 스코프 체인은 함수가 정의된 위치에 기반하여 형성됩니다. 내부 함수는 외부 함수의 스코프에 접근할 수 있지만, 외부 함수는 내부 함수의 스코프에 직접 접근할 수 없습니다.',
  },
  {
    question: 'this의 용법에 대해 아는대로 설명해주세요.',
    answer:
      '객체 내부에서: "this"는 객체 내부의 메서드에서 사용되며, 해당 메서드가 속한 객체를 가리킵니다. 이를 통해 객체의 속성 및 메서드에 접근할 수 있습니다. 함수 내부에서: 함수 내부에서 "this"는 실행 컨텍스트에 따라 다르게 동작합니다. 일반적인 함수 호출에서는 전역 객체를 가리키며, 메서드 내에서는 해당 객체를 가리킵니다. 생성자 함수 내부에서: 생성자 함수 내부에서 "this"는 새로운 인스턴스를 가리킵니다. 이를 통해 새로운 객체에 속성 및 메서드를 추가할 수 있습니다. 이벤트 핸들러에서: 이벤트 핸들러에서 "this"는 이벤트가 발생한 요소를 가리킵니다. 이를 통해 이벤트와 관련된 작업을 수행할 수 있습니다. 화살표 함수에서: 화살표 함수 내부에서 "this"는 함수가 정의된 컨텍스트를 유지하며, 일반적인 함수와 다르게 동작합니다. "this"의 값은 실행 컨텍스트에 따라 동적으로 변경되며, 코드 내에서 어떻게 호출되었느냐에 따라 달라집니다.',
  },
  {
    question: 'setTimeout 에서 this는 왜 전역을 가리키는지 설명하세요.',
    answer:
      'setTimeout()에 의해 실행된 코드는 별도의 실행 컨텍스트에서 setTimeout이 호출된 함수로 호출됩니다. this는 함수의 호출 방식에 의해서 결정되기에, this를 호출된 함수에서 설정 혹은 할당하지 않는 경우 non-strict모드에서는 전역 혹은 window 객체, strict 모드에서는 undefined를 기본 값으로 합니다. 그렇기에 setTimeOut함수를 이용할 때 window객체나 undefined가 출력되는 에러를 볼 수 있습니다. 이 방법을 해결하기 위해서는 3가지 해결책이 있습니다 1. this 설정이 필요한 곳을 함수로 감싸주기 2. 화살표 함수로 작성 3. bind를 활용해서 this를 지정해주기',
  },
  {
    question: 'JavaScript의 ES6 이후 추가된 기능은 무엇이 있습니까?',
    answer:
      '1. let 및 const 키워드 : let과 const는 블록 스코프를 갖는 변수를 선언하는 데 사용됩니다. let은 변수를 재할당할 수 있지만 const는 재할당이 불가능한 상수를 선언합니다. 2. 화살표 함수 (Arrow Functions) : 화살표 함수는 익명 함수를 간결하게 표현하는데 사용됩니다. 함수가 한 줄의 표현식만을 포함할 경우 중괄호 {}와 return 키워드를 생략할 수 있습니다. 3. 템플릿 리터럴 (Template Literals) : 템플릿 리터럴은 문자열을 역 따옴표(backticks)로 감싸고 ${} 구문을 사용하여 변수나 표현식을 문자열에 삽입할 수 있습니다. 4. 디스트럭처링 할당 (Destructuring Assignment) : 디스트럭처링은 배열이나 객체의 값을 추출하여 여러 변수에 할당하는 방법입니다. 이를 통해 코드를 간결하게 작성할 수 있습니다. 5. 클래스 (Classes) : 클래스는 객체 지향 프로그래밍을 지원하는 새로운 문법입니다. 생성자 메서드 constructor를 사용하여 객체를 초기화하고, 클래스 내에서 메서드를 정의할 수 있습니다. 6. 모듈 (Modules) : 모듈은 코드를 여러 파일로 나누고, 필요한 부분만 가져와서 사용할 수 있게 하는 시스템입니다. export와 import 키워드를 사용하여 모듈 간의 의존성을 관리합니다. 7. Promise와 비동기 처리 (Promises and Asynchronous Programming) : Promise는 비동기 작업을 처리하기 위한 객체로, 비동기 코드를 좀 더 직관적으로 작성할 수 있게 도와줍니다. resolve와 reject를 통해 성공과 실패를 다룰 수 있습니다. 8. 나머지 매개변수와 전개 연산자 (Rest Parameters and Spread Operator) : 나머지 매개변수는 함수에 전달된 인수들을 배열로 수집합니다. 전개 연산자는 배열이나 객체를 개별 요소로 분해하거나, 여러 개의 요소를 배열이나 객체에 합칠 때 사용됩니다.',
  },
  {
    question: ' null, undefined, undeclared, NaN 에 대해 설명해주세요.',
    answer:
      'null : 빈 값이라는 의미, 사용자가 의도적으로 변수에 null을 할당하여 값이 없다는 것을 나타낼 때 사용합니다. undefined : 변수가 선언만 되고 값이 할당되어 있지 않은 상태. 예로 var 선언문의 경우, 변수 선언과 초기화가 동시에 일어나기 때문에 호이스팅 되었을 때 변수는 존재하지만 값이 undefined로 설정됩니다. undeclared : 접근 가능한 스코프에 변수 선언조차 되어있지 않은 상태. let, const 선언문의 경우, 변수 선언과 초기화가 따로 이루어지기에 호이스팅 되었을 때 변수가 undeclared 되어 에러가 생깁니다. NaN : "Not a Number" 숫자가 아니라는 의미, 연산 과정에서 잘못된 입력을 받아 숫자로 나타낼 수 없을 때 나타내는 표시입니다.',
  },
  {
    question: '얕은 복사와 깊은 복사에 대해서 설명해보세요.',
    answer:
      '얕은 복사 (Shallow Copy) : 얕은 복사는 원본 객체나 배열을 복사할 때, 해당 객체나 배열의 참조를 복사하는 방식입니다. 즉, 복사된 객체나 배열은 원본과 같은 내부 참조를 공유합니다. 따라서 복사된 객체나 배열을 수정하면 원본 객체나 배열도 영향을 받을 수 있습니다. 깊은 복사 (Deep Copy) : 깊은 복사는 원본 객체나 배열을 완전히 새로운 객체나 배열로 복사하는 방식입니다. 복사된 객체나 배열은 원본과는 독립적으로 존재하며, 내부 구조까지 복사됩니다. 따라서 복사된 객체나 배열을 수정하더라도 원본에는 영향을 주지 않습니다. JavaScript에서 깊은 복사를 수행하는 방법은 여러 가지가 있습니다. 예를 들어, JSON.stringify()와 JSON.parse()를 사용하여 깊은 복사를 할 수 있습니다:',
  },
  {
    question: '브라우저 렌더링 과정에 대해서 설명해주세요.',
    answer:
      '1. 문서 파싱 (Document Parsing): 웹 브라우저가 서버로부터 웹 페이지의 HTML과 CSS 파일을 다운로드합니다. 다운로드가 완료되면, 브라우저는 HTML 문서를 파싱하여 문서 객체 모델(DOM)을 생성하고, CSS 파일을 파싱하여 CSS 객체 모델(CSSOM)을 생성합니다. 2. DOM과 CSSOM 결합 (DOM and CSSOM Combining): DOM과 CSSOM은 각각 HTML 문서의 요소와 스타일 정보를 나타냅니다. 이 두 모델을 결합하여 렌더링 트리(Render Tree)라고 하는 새로운 트리를 생성합니다. 렌더링 트리는 실제로 화면에 표시될 요소와 스타일 정보만을 포함하며, 레이아웃을 위한 정보는 아직 포함되지 않습니다. 3. 레이아웃 (Layout): 렌더링 트리가 생성되면, 브라우저는 요소의 위치와 크기를 계산하여 화면 상에 어떻게 배치할지 결정합니다. 이 과정을 레이아웃 또는 리플로우(reflow)라고 합니다. 요소의 크기가 변경되거나, 레이아웃에 영향을 주는 스타일 변경이 발생하면 레이아웃 단계가 다시 수행됩니다. 4. 페인팅 (Painting): 화면에 표시할 내용을 결정한 후, 브라우저는 실제로 화면에 그리기 위해 렌더링 트리를 사용합니다. 이 과정을 페인팅 또는 랜더링(rendering)이라고 합니다. 브라우저는 각 요소의 스타일 정보를 사용하여 화면에 해당 요소를 그리고 색상, 배경, 텍스트 등을 채웁니다. 5. 합성 (Compositing): 각 요소가 화면에 그려진 후, 레이어를 조합하여 최종 화면을 생성합니다. 이 단계에서 브라우저는 요소의 위치, 투명도, 색상 등을 고려하여 화면을 최적화하고 합성합니다. 6. 화면 표시 (Display on Screen): 마지막으로, 최종 화면이 실제 디스플레이에 표시됩니다. 사용자는 웹 페이지를 볼 수 있게 됩니다.',
  },
  {
    question: 'REST API란 무엇인지 설명해주세요.',
    answer:
      'REST : 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것. API : 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환 가능하도록 하는 것. REST API : REST를 기반으로 서비스 API를 구현한 것. 등장 배경 : 단순하게 하나의 브라우저만 지원하면 됐던 이전과 달리, 최근에는 여러 웹 브라우저는 물론, 아이폰, 안드로이드 등과의 통신에 대응해야 했기에 범용적으로 사용성을 보장하는 서버 디자인이 필요해짐. 특징 : REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현. REST API는 HTTP 요청을 통해 통신함으로써 리소스 내에서 데이터(CRUD 라고도 함)의 작성, 읽기, 업데이트 및 삭제 등의 데이터베이스 기능을 수행합니다. 예를 들어, GET 요청을하여 데이터를 검색하고, POST 요청을 사용해 데이터를 작성하며, PUT을 통해 데이터를 업데이트, DELETE를 통해 데이터를 삭제합니다.',
  },
  {
    question: '클래스에 있는 값이 인스턴스에 영향을 주면 안되는 이유가 뭔가요?',
    answer:
      '클래스에 있는 값이 인스턴스에 영향을 주면, 코드의 안정성과 예측 가능성이 떨어지며, 수정이 어려워지고 코드의 재사용성이 감소하여 유지 보수성이 떨어집니다. 이를 피하기 위해 클래스와 인스턴스는 독립적으로 작동하도록 만들어야 하며, 데이터 은닉으로 서로 간섭하지 않도록 보호해야 합니다. 데이터 은닉은 캡슐화와 모듈화를 가능하게 하여  클래스와 인스턴스 간의 독립성을 유지하고, 클래스를 수정할 때 클래스 외부에 영향을 미치지 않고 내부 구현을 변경할 수 있습니다. 또한 각각의 역할을 명확히 분리함으로써 유지 보수성을 높이고 코드의 안정성을 보장할 수 있습니다.',
  },
  {
    question: '메서드 오버라이드와 오버로딩에 대해서 설명해주세요.',
    answer:
      '자바스크립트는 동적 타입 언어이기 때문에 정적인 메소드 오버로딩과 오버라이딩의 개념이 다른 언어와는 조금 다르지만 비슷하게 구현이 가능합니다. 1. 메소드 오버라이딩 : 상속 관계에 있는 클래스에서 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것. 프로토타입 체인을 통해 구현 가능. 예시) 부모 클래스와 자식 클래스가 있을 때, 자식 클래스에서 같은 이름의 메소드를 정의하면 해당 객체 인스턴스에서 해당 메소드를 호출하면 자식 클래스에 정의된 메소드가 실행됨 2. 메소드 오버로딩 : 같은 이름을 가진 여러 개의 함수를 매개변수 형태나 개수에 따라 다르게 처리. 자스에서 직접적으로 지원하지 않음. 자스에서 사용하려면 함수 내부에서 매개변수 유형 및 개수에 따라 분기 처리하여 원하는동작 수행가능 또는 자스에서는 매개변수 정보를 담고 있는 arguments를 사용해 오버로딩을 흉내낼 수 있다',
  },
  {
    question:
      '브라우저 저장소의 차이점에 대해 설명해주세요. (LocalStorage,SessionStorage,Cookie)',
    answer:
      '브라우저 저장소란 해당 도메인과 관련된 특정 데이터를 서버가 아니라 클라이언트 웹 브라우저에 저장할 수 있도록 제공하는 기능입니다. HTML 5 전에는 주로 쿠키를 통해 클라이언트 측에 데이터를 저장하였습니다. 하지만 쿠키는 최대 4KB크기를 가지고 있어 대량의 데이터를 저장하기엔 적합하지 않았고, 모든 HTTP 요청에 포함되어 서버로 전송되기 때문에 불필요하게 트래픽을 발생시킬 수 있었습니다. HTML 5부터 새로운 자료구조인 웹 스토리지가 도입되면서 쿠키의 단점을 보완할 수 있게 되었습니다. 웹 스토리지는 저장된 데이터가 클라이언트에 존재할 뿐 서버에는 전송되지 않아 트래픽 비용을 줄일 수 있습니다. 웹 스토리지에는 로컬 스토리지와 세션 스토리지가 있습니다. 로컬 스토리지는 저장한 데이터를 지우지 않는 이상 영구적으로 보관이 가능하고 세션 스토리지는 로컬 스토리지와 반대로 데이터가 지속적으로 보관되지 않으며 현재 페이지가 브라우징되고 있는 브라우저 컨텍스트 내에서만 데이터가 유지됩니다. 브라우저가 닫히거나 세션이 종료되면 데이터가 삭제됩니다.',
  },
  {
    question: 'SPA, CSR, SSR의 차이에 대해 설명해주세요.',
    answer:
      'SPA (Single Page Application) : SPA는 단일 페이지 웹 애플리케이션입니다. 전통적인 웹 페이지 방식과 달리 SPA는 사용자와 상호작용할 때 전체 페이지를 새로 고치지 않습니다. 대신, 필요한 부분만 업데이트합니다. 특징 : 페이지 전환 없이 웹사이트 내에서의 사용자 경험을 부드럽게 만듭니다. 초기 로딩이 다소 느릴 수 있지만, 이후의 상호작용은 빠르게 반응합니다. 주로 AJAX와 함께 사용하여 서버에서 필요한 데이터만을 가져옵니다. CSR (Client-Side Rendering) : CSR은 웹 페이지의 내용을 브라우저(클라이언트)에서 동적으로 렌더링하는 방식입니다. 특징 : 서버에서는 최소한의 HTML 및 JavaScript만 전송되며, JavaScript가 클라이언트에서 실행될 때 페이지의 내용이 생성됩니다. 첫 페이지 로딩이 다소 느릴 수 있으나, 일단 로딩되면 사용자 상호작용에 빠르게 반응합니다. SPA가 주로 CSR 방식을 사용합니다. SSR (Server-Side Rendering) : SSR은 웹 페이지의 내용을 서버에서 렌더링하여 클라이언트에게 전송하는 방식입니다. 특징 : 사용자는 빠르게 첫 화면을 볼 수 있지만, 상호작용이 가능하려면 JavaScript가 완전히 로드 및 실행되어야 합니다. SEO(Search Engine Optimization)에 유리한 경우가 많습니다, 왜냐하면 크롤러가 완전히 렌더링 된 페이지의 내용을 쉽게 파싱할 수 있기 때문입니다. 서버에 부하가 더 많이 가는 경향이 있습니다, 각 요청마다 페이지를 렌더링해야 하기 때문입니다.',
  },
  {
    question: 'CORS에 대처하는 방법과 우회하는 방법에 대해 설명해주세요.',
    answer:
      'CORS(Cross-Origin Resource Sharing) • 프로토콜, 도메인, 포트번호 중 하나라도 서로 다른 출처에 있는 리소스에 접근 가능하게 해주는 정책. • 브라우저는 기본적으로 서로 다른 출처에 대해 공유를 제한하는 SOP(Same Origin Policy)를 따르는데, 다른 출처에 리소스를 공유하기 위해서는 CORS를 정의해 사용해야 한다. • 그렇지 않으면 웹 개발 시 자바스크립트로 외부 서버의 경로에 ajax 요청을 날리면 CORS 에러가 발생한다. CORS에러가 발생할 경우 1. 서버 개발 쪽에 요청이 가능한 경우 : 서버에서CORS  요청이 허용되도록 구현 2. 크롬 같은 웹 브라우저 실행 시 외부 요청을 허용하는 옵션을 사용, 외부 요청을 가능하게 해 주는 플러그인 설치하여 SOP 회피 3. css나 js 같은 리소스 파일들은 SOP에 영향을 받지 않고 로딩이 가능하다는 점을 이용해 외부 서버에서 읽어온 js파일을 json으로 바꿔주는 JSONP방식 요청',
  },
  //   {
  //     question: '질문',
  //     answer: '답변',
  //   },
];

export default questionsData;
